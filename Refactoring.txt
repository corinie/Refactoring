2018/05/28 Test-Driven Development : By Example 
From 1 to 87 Page
지호

일반적인 개발 프로세스 = 디자인 > 코드 작성 > (수동) 테스트 > 처음으로 돌아가 설계(디자인) 수정
TDD = 
Definition: 정확한 프로그래밍 목적을 디자인 단계에서 정의
RED: 실패하는 테스트 만들기
GREEN: 테스트에 통과할 만한 작은 코드를 작성하기
REFACTOR : 반복되는 코드, 긴 메소드, 큰 클래스, 긴 매개 변수 목록 등 코드를 효율적으로 바꾸기


구체적인 방법론 
1. 작은 테스트를 하나 추가한다
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.




EX)다중 통화를 지원하는 MONEY 객체의 예제
1차 정의 리스트
(
	$5 + 10CHF = $10 (환율이 2:1일 경우)
	$5 * 2 = $10
	amount를 private로 만들기
	Dollar의 부작용?
	Money의 반올림
)
각각의 리스트 항목을 처리하기 위한 작은 테스트를 진행한다.
컴파일 가능한, 그 후 생기는 문제점에 대해 다시 리스트 업하면서 진행한다.


ISSUE KEYWORD 의존성과 중복의 관계


=================================================================================================
2018/05/28 자바 성능 튜닝 이야기
From 1 to 118 Page
진성

StringBuffer
스레드에 안전하게 설계되어 있다.
여러개의 스레드에서 하나의 StringBuffer 객체를 처리해도 문제없다

StringBilder
단일 스레드에서만 안전성 보장
여러개의 스레드에서 하나의 StringBilder 객체를 처리하면 문제가 발생 할 수 있다.

-String은 짧은 문자열을 더할 경우 사용
-StringBuffer는 스레드에 안전한 프로그램이 필요할 때나, 개발 중인 시스템의 부분이
스레드에 안전한지 모를 경우 사용
-StringBilder는 스레드에 안전한지의 여부와 전혀 관계없는 프로그램을 개발할때 사용

--------------------------------------------------------------------------------

Collection

Set
데이터 추가 속도
1. HashSet
2. LinkedHashSet
3. TreeSet

저장되는 데이터의 크기를 알고 있을 경우에는 객체 생성시 크기를 미리 지정하는 
것이 성능상 유리

데이터 읽는 속도
1. LinkedHashSet
2. HashSet
3. TreeSet

데이터를 순서에 따라 탐색하는 작업이 필요할 때는 TreeSet을 사용하는 것이 좋다.
그럴필요가 없을 때는 HashSet이나 LinkedHashSet을 사용하는 것이 좋다.

List
데이터 추가 속도
1. ArrayList
2. Vector
3. LinkedList

데이터를 넣는 속도는 어떤 클래스든 큰 차이가 없다.

데이터 읽는 속도 
1. ArrayList
2. Vector
3. LinkedList

Vector는 여러스레드에서 접근 할 경우를 방지하기 위해서 get()메서드에 Synchronized
가 선언되어 있다.

--------------------------------------------------------------------------------

for 루프 성능 UP!

for(int i; i<list.size(); i++) X
매번 반복하면서 list.size()메서드를 호출하기 때문

int listSize = list.size();
for(int i; i<listSize; i++) O

반복문에서 동일한 메서드 반복 호출을 조심하자!

--------------------------------------------------------------------------------

Static 잘 활용하기

1. 자주 사용하고 절대 변하지 않는 변수는 final static으로 선언
2. 설정파일 정보 static으로 관리
3. 코드성 데이터는 DB에서 한번만 읽자 

================================================================================

2018/05/28 Refactoring : By martin fowler 
From 1 to 40 Page

채환

흔히 설계를 잡고 코드를 작성한다고 하는데,
리팩토링의 개념은 코드를 작성한 후 설계를 개선하는 일이라 말한다.
리팩토링을 진행하면서 새로운 로직이 생기는 게 아니라 기존의 기능을 바꾸지 않으면서 내부 구조를 개선하는 것이므로 곧바로 육안으로 확인할 순 없지만 장기적으로는 좋은 프로그램으로 발전하기 위해 필수적이다.

설계가 조잡하다면 시스템 수정이 발생시 찾느랴 고생해야 하고 실수할 가능성이 높아져서 버그가 생긴다.

===================================================================================
2018/05/28 Test-Driven Development : By Example 
From 1 to 87 Page


2018/05/29 Refactoring:프로그램의 가치를 높이는 코드 정리 기술
From 1 to 76 Page 
성현

01.

ｏ 리팩토링

- 겉으로 드러나는 코드의 기능은 변경하지 않으면서 내부 구조를 개선하는 방식으로
소프트웨어 시스템을 수정하는 방법, 리팩토링을 한다는 것은 코드를 작성하고난 뒤 설계를
향상시키는 일이다.

- 객체지향 방식은 리팩토링을 실시하기에 적합한 언어

- 프로그램을 조금씩 단계적으로 수정하므로 실수해도 버그를 찾기 쉽다.

ｏ 리팩토링을 적용할 시기

- 추후 재사용이나 수정할 일이 있는 프로그램이 당장은 문제가 없을지 몰라도 나중에 사용자가
요구한 기능을 수정하기 힘들어서 애먹을 경우

ｏ 리팩토링의 첫 단계

- 리팩토링할 코드 부분에 대한 신뢰도 높은 각정 테스트를 작성 실수할 수 있기 때문에 신뢰도
높은 테스트 작성은 필수다.

ｏ 메서드 분해와 기능 재분배

- 긴 메서드를 보면 작은 부분들로 쪼갤 수 있는지 살펴본다. 코드를 잘게 쪼개면 관리도 편하고
다른 코드와 연동하거나 이리저리 옮기기도 쉽다.

ｏ 용도가 드러나게 코드를 작성

- 바람직하지 않는 변수명은 수정해야한다. 좋은 코드는 그것이 무슨 기능을 하는지 분명히
드러나야 하는데, 코드의 기능을 드러내는 열쇠가 직관적인 변수명이다.

- 컴퓨터가 인식 가능한 코드는 바보라도 작성할 수 있지만, 인간이 이해할 수있는 코드는
실력있는 프로그래머만 작성할 수 있다.

ｏ 변수의 불필요한 사용

- 계속 사용되지 않는 변수를 임시변수라고 부르는데, 임시변수는 메소드 호출로 전환해서
사용하고 변수를 삭제해야 한다. 임시변수는 최대한 없애든 것이 좋다. 임시변수가 많으면
매개변수를 전달하게 되는 문제가 흔히 생긴다.

ｏ swithch문의 인자

- switch문의 인자로는 타 객체 데이터를 사용하지 말고 자신의 데이터를 사용해야한다.


02.

ｏ 리팩토링은 무엇인가?

- '리팩토링' 용어는 문맥에 따라 두 가지 의미로 정의되며, 명사는 겉으로 드러나는 기능을 그대로
둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업이고, 동사는 리팩토링
기법을 연달아 적용해서 겉으로 드러나는 기능을 그대로 둔 채, 소프트웨어 구조를 변경한다.

- 리팩토링은 단순히 코드 정리 작업만이 아니라, 코드 효율성도 높아지고 구조도 체계화되기에
단순한 코드 정리보다는 포괄적인 개념이라고 할 수 있다.


===============================================================================================
2018/05/29 Test-Driven Development : By Example 
From 88 to 157 Page

지호

TDD 후에 해야할 일 - 다음 할 일은 무엇인가? / 현재의 설계로는 제거하기 힘든 중복이 있는가?

메타포 - 설계 구조에 미치는 메타포의 엄청난 영향 
/ 작성한 프로그램을 20번씩 다시 작성해본다면, 매번 새로운 통찰을 얻고 놀라움을 경험할 것인가?, 신중을 기해서 3번, 한번으로 다 얻어 낼 것인가?

JUnit 사용도 - 언제 테스트를 실행했으며, JUnit을 어떻게 사용해 왔는가

코드 매트릭스 - 결과 코드의 수치화

프로세스 - 빨강/초록/ 리팩토링 순서에 대해 이야기 했는데,그렇다면 각 단계에서 얼마 만큼 작업해야 하는가

테스트의 질 - 전통적인 테스트 매트릭스에 TDD 테스트가 어떻게 필적할 수 있는가
/성능 테스트, 스트레스 테스트, 사용성 테스트

명령문 커버리지 = 충분한 평가 기준이 될수 없지만, 시작점이다. 실제 모델 코드를 위해서 작성한 것이 아니라 디버깅을 위해 작성한 것이다. 
결함 삽입 = 코드의 의미를 바꾼 후에 테스트가 실패하는지 보는 것이다. jester같은 툴을 이용할 수 있다. 




TDD 최종검토
-테스트를 확실하게 돌아가게 만드는 세가지 접근 방법 
	가짜로 구현하기
	삼각측량법
	명백하기 구현하기

-설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복을 제거하기

-길이 미끄러우면 속도를 줄이고 상황이 좋은면 속도를 높이는 식으로 테스트 사이의 간격을 조절할 수 있는 능력

