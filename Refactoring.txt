2018/05/28 Test-Driven Development : By Example 
From 1 to 87 Page
지호

일반적인 개발 프로세스 = 디자인 > 코드 작성 > (수동) 테스트 > 처음으로 돌아가 설계(디자인) 수정
TDD = 
Definition: 정확한 프로그래밍 목적을 디자인 단계에서 정의
RED: 실패하는 테스트 만들기
GREEN: 테스트에 통과할 만한 작은 코드를 작성하기
REFACTOR : 반복되는 코드, 긴 메소드, 큰 클래스, 긴 매개 변수 목록 등 코드를 효율적으로 바꾸기


구체적인 방법론 
1. 작은 테스트를 하나 추가한다
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.




EX)다중 통화를 지원하는 MONEY 객체의 예제
1차 정의 리스트
(
	$5 + 10CHF = $10 (환율이 2:1일 경우)
	$5 * 2 = $10
	amount를 private로 만들기
	Dollar의 부작용?
	Money의 반올림
)
각각의 리스트 항목을 처리하기 위한 작은 테스트를 진행한다.
컴파일 가능한, 그 후 생기는 문제점에 대해 다시 리스트 업하면서 진행한다.


ISSUE KEYWORD 의존성과 중복의 관계


=================================================================================================
2018/05/28 자바 성능 튜닝 이야기
From 1 to 118 Page
진성

StringBuffer
스레드에 안전하게 설계되어 있다.
여러개의 스레드에서 하나의 StringBuffer 객체를 처리해도 문제없다

StringBilder
단일 스레드에서만 안전성 보장
여러개의 스레드에서 하나의 StringBilder 객체를 처리하면 문제가 발생 할 수 있다.

-String은 짧은 문자열을 더할 경우 사용
-StringBuffer는 스레드에 안전한 프로그램이 필요할 때나, 개발 중인 시스템의 부분이
스레드에 안전한지 모를 경우 사용
-StringBilder는 스레드에 안전한지의 여부와 전혀 관계없는 프로그램을 개발할때 사용

--------------------------------------------------------------------------------

Collection

Set
데이터 추가 속도
1. HashSet
2. LinkedHashSet
3. TreeSet

저장되는 데이터의 크기를 알고 있을 경우에는 객체 생성시 크기를 미리 지정하는 
것이 성능상 유리

데이터 읽는 속도
1. LinkedHashSet
2. HashSet
3. TreeSet

데이터를 순서에 따라 탐색하는 작업이 필요할 때는 TreeSet을 사용하는 것이 좋다.
그럴필요가 없을 때는 HashSet이나 LinkedHashSet을 사용하는 것이 좋다.

List
데이터 추가 속도
1. ArrayList
2. Vector
3. LinkedList

데이터를 넣는 속도는 어떤 클래스든 큰 차이가 없다.

데이터 읽는 속도 
1. ArrayList
2. Vector
3. LinkedList

Vector는 여러스레드에서 접근 할 경우를 방지하기 위해서 get()메서드에 Synchronized
가 선언되어 있다.

--------------------------------------------------------------------------------

for 루프 성능 UP!

for(int i; i<list.size(); i++) X
매번 반복하면서 list.size()메서드를 호출하기 때문

int listSize = list.size();
for(int i; i<listSize; i++) O

반복문에서 동일한 메서드 반복 호출을 조심하자!

--------------------------------------------------------------------------------

Static 잘 활용하기

1. 자주 사용하고 절대 변하지 않는 변수는 final static으로 선언
2. 설정파일 정보 static으로 관리
3. 코드성 데이터는 DB에서 한번만 읽자 

================================================================================

2018/05/28 Refactoring : By martin fowler 
From 1 to 40 Page

채환

흔히 설계를 잡고 코드를 작성한다고 하는데,
리팩토링의 개념은 코드를 작성한 후 설계를 개선하는 일이라 말한다.
리팩토링을 진행하면서 새로운 로직이 생기는 게 아니라 기존의 기능을 바꾸지 않으면서 내부 구조를 개선하는 것이므로 곧바로 육안으로 확인할 순 없지만 장기적으로는 좋은 프로그램으로 발전하기 위해 필수적이다.

설계가 조잡하다면 시스템 수정이 발생시 찾느랴 고생해야 하고 실수할 가능성이 높아져서 버그가 생긴다.

===================================================================================
2018/05/28 Test-Driven Development : By Example 
From 1 to 87 Page


2018/05/29 Refactoring:프로그램의 가치를 높이는 코드 정리 기술
From 1 to 76 Page 
성현

01.

ｏ 리팩토링

- 겉으로 드러나는 코드의 기능은 변경하지 않으면서 내부 구조를 개선하는 방식으로
소프트웨어 시스템을 수정하는 방법, 리팩토링을 한다는 것은 코드를 작성하고난 뒤 설계를
향상시키는 일이다.

- 객체지향 방식은 리팩토링을 실시하기에 적합한 언어

- 프로그램을 조금씩 단계적으로 수정하므로 실수해도 버그를 찾기 쉽다.

ｏ 리팩토링을 적용할 시기

- 추후 재사용이나 수정할 일이 있는 프로그램이 당장은 문제가 없을지 몰라도 나중에 사용자가
요구한 기능을 수정하기 힘들어서 애먹을 경우

ｏ 리팩토링의 첫 단계

- 리팩토링할 코드 부분에 대한 신뢰도 높은 각정 테스트를 작성 실수할 수 있기 때문에 신뢰도
높은 테스트 작성은 필수다.

ｏ 메서드 분해와 기능 재분배

- 긴 메서드를 보면 작은 부분들로 쪼갤 수 있는지 살펴본다. 코드를 잘게 쪼개면 관리도 편하고
다른 코드와 연동하거나 이리저리 옮기기도 쉽다.

ｏ 용도가 드러나게 코드를 작성

- 바람직하지 않는 변수명은 수정해야한다. 좋은 코드는 그것이 무슨 기능을 하는지 분명히
드러나야 하는데, 코드의 기능을 드러내는 열쇠가 직관적인 변수명이다.

- 컴퓨터가 인식 가능한 코드는 바보라도 작성할 수 있지만, 인간이 이해할 수있는 코드는
실력있는 프로그래머만 작성할 수 있다.

ｏ 변수의 불필요한 사용

- 계속 사용되지 않는 변수를 임시변수라고 부르는데, 임시변수는 메소드 호출로 전환해서
사용하고 변수를 삭제해야 한다. 임시변수는 최대한 없애든 것이 좋다. 임시변수가 많으면
매개변수를 전달하게 되는 문제가 흔히 생긴다.

ｏ swithch문의 인자

- switch문의 인자로는 타 객체 데이터를 사용하지 말고 자신의 데이터를 사용해야한다.


02.

ｏ 리팩토링은 무엇인가?

- '리팩토링' 용어는 문맥에 따라 두 가지 의미로 정의되며, 명사는 겉으로 드러나는 기능을 그대로
둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업이고, 동사는 리팩토링
기법을 연달아 적용해서 겉으로 드러나는 기능을 그대로 둔 채, 소프트웨어 구조를 변경한다.

- 리팩토링은 단순히 코드 정리 작업만이 아니라, 코드 효율성도 높아지고 구조도 체계화되기에
단순한 코드 정리보다는 포괄적인 개념이라고 할 수 있다.


===============================================================================================
2018/05/29 Test-Driven Development : By Example 
From 88 to 157 Page

지호

TDD 후에 해야할 일 - 다음 할 일은 무엇인가? / 현재의 설계로는 제거하기 힘든 중복이 있는가?

메타포 - 설계 구조에 미치는 메타포의 엄청난 영향 
/ 작성한 프로그램을 20번씩 다시 작성해본다면, 매번 새로운 통찰을 얻고 놀라움을 경험할 것인가?, 신중을 기해서 3번, 한번으로 다 얻어 낼 것인가?

JUnit 사용도 - 언제 테스트를 실행했으며, JUnit을 어떻게 사용해 왔는가

코드 매트릭스 - 결과 코드의 수치화

프로세스 - 빨강/초록/ 리팩토링 순서에 대해 이야기 했는데,그렇다면 각 단계에서 얼마 만큼 작업해야 하는가

테스트의 질 - 전통적인 테스트 매트릭스에 TDD 테스트가 어떻게 필적할 수 있는가
/성능 테스트, 스트레스 테스트, 사용성 테스트

명령문 커버리지 = 충분한 평가 기준이 될수 없지만, 시작점이다. 실제 모델 코드를 위해서 작성한 것이 아니라 디버깅을 위해 작성한 것이다. 
결함 삽입 = 코드의 의미를 바꾼 후에 테스트가 실패하는지 보는 것이다. jester같은 툴을 이용할 수 있다. 




TDD 최종검토
-테스트를 확실하게 돌아가게 만드는 세가지 접근 방법 
	가짜로 구현하기
	삼각측량법
	명백하기 구현하기

-설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복을 제거하기

-길이 미끄러우면 속도를 줄이고 상황이 좋은면 속도를 높이는 식으로 테스트 사이의 간격을 조절할 수 있는 능력

---------------------------------------------------------------------------------

2018/05/29 자바 성능 튜닝 이야기
From 119 to 219 Page

진성

스레드

하나의 프로세스에는 여러개의 스레드가 생성된다.

synchronized
-하나의 객체를 여러 스레드에서 동시에 사용할경우 사용
-static으로 선언한 객체를 여러스레드에서 동시에 사용할 겨우 사용

반드시 필요한 부분에만 동기화를 사용해야한다.

-------------------------------------------------------------------------------

IO

IO는 성능에 영향을 가장 많이 미친다.

BufferReader 클래스는 다른 FileReder 클래스와 마찬가지로 문자열 단위나 문자열 
배열 단위로 읽을 수 있는 기능을 제공하지만, 추가로 라인단위로 읽을 수 있는 
readLin() 메서드를 제공한다

FileReader보다 성능이 좋다.

--------------------------------------------------------------------------------

System.out.println()의 문제점

내용이 완전히 프린트되거나 저장 될 때까지 뒤에 프린트하려는 부분은 대기할 수 밖에
없다. 그렇게되면 애플리케이션에는 대기시간이 발생한다. 더 큰 문제는 System.out.println()
으로 출력하는 로그가 개발할 때만 사용된다는 것이다.

--------------------------------------------------------------------------------

적절한 include 사용하기

include 기능을 사용하면, 하나의 JSP에서 다른 JSP를 호출하여 어러 JSP파일을 혼합해서
하나의 JSP로 만들 수 있다.
정적인 방식, 동적인 방식 두가지 방식이 있다. 성능을 더 빠르게 할려면 정적인 방식을
사용해야 한다. 상황에 맞게 알맞은 include 방식을 선택하여 사용하여야 한다.

--------------------------------------------------------------------------------

스프링 프레임워크를 사용하면서 발생할 수 있는 문제점들

스프링 프레임워크를 사용할 때 성능문제가 가장 많이 발생하는 부분은 프록시와 관련
되어 있다.
@Transactional 어노테이션을 사용하면 해당 어노테이션을 사용한 클래스의 인스턴스를
처음 만들 때 프록시 객체를 만든다. 이 밖에도 개발자가 직접 스프링 AOP를 사용해서
별도의 기능을 추가하는 경우에도 프록시를 사용하는데 개발자가 직접 작성한 AOP코드는
예상치 못한 성능 문제를 보일 가능성이 매우 높다.

동일한 문자열에 대한 뷰 객체를 새로 찾기 보다는 이미 찾아본 뷰객체를 캐싱해두면 
다음에도 동일한 문자열이 변환됐을 때 훨씬 빠르게 뷰 객체를 찾을 수 있다.
매번 다른 문자열이 생성될 가능성이 높고 상당히 많은 수의 키값으로 캐시값이 생성될
여지가 있는 상황에서는 문자열을 반환하는게 메모리에 치명적 일 수 있다. 따라서 이런
상황에서는 뷰 이름을 문자열로 반환하기보다는 뷰 객체를 자체를 반환하는 방법이 
메모리 릭을 방지하는데 도움이 된다.

--------------------------------------------------------------------------------
==========================================================
2018/05/29 Refactoring : By martin fowler 
From 40 to 105 Page

< 정 채 환 >
리팩토링(refactoring)의 변환 단계(하나의 예시일 뿐).
	1. 코드에서 메서드를 추출.
	2. 알맞은 클래스로 메서드 이동.
	3. 조건문을 재정의로 전환.
많은 것을 한꺼번에 바꾸려고 크게 생각하지 말고, 간단하고 작게 하나하나 씩 적용하고 테스트하고를 반복하면 좋다. 왜냐 아직 코드 찌질이니깐.

리팩토링의 방법에는 여러가지가 존재한다.
그 중 하나를 선택하여 리팩토링을 적용한다고 해도 다른 방법론이 필요할 때가 많다.

리팩토링 용어의 정의 두 가지.
	1. 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업이다.
	2. 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경한다.

리팩토링(refactoring)과 성능 최적화의 개념 차이.
	둘 다 기능이 변경되지 않고 내부 구조를 변경하는 것은 같으나,
	성능 최적화는 코드가 파악하기 어려워 질 수 있지만 리팩토링은 단순화한다.
	성능 최적화는 속도가 빨라질 수 있으나, 리팩토링은 거의 그대로이다.

켄트 백의 '모자 두개' 비유법.
	리팩토링은 소프트웨어 개발을 하면서 단 한번만 이뤄지는 과정이 결코 아니다.
	개발(기능 추가)를 하는 동시에 복잡하지는 구조를 발견하고 개선해나가는 것이다.
	둘 다 동시에 할 수는 없다.
	반드시 두 작업 중 진행 중인 작업을 멈추고 다른 작업을 실행해야 한다.
	리팩토링작업과 기능추가작업으로 보면된다.
	켄트 백은 이 두 작업이 수시로 일어나는 걸 모자 두개로 비유했다.
	'기능 추가 모자', '리팩토링 모자'

중복 코드 제거는 깔끔한 설계의 필수 요건이다.

리팩토링을 대체 어떤 주기로 어느 정도 시간을 투자해야 할까 ?
	그런 기준은 전혀 없다.
	일상적으로 틈틈히 해야 한다.
	필요로 인해 하게 된다.(귀찮음주의)

	기준이 있다면 돈 로버츠의 '삼진 아웃'.
	어떤 작업을 처음 수행할 때 그냥 작성하고 같은 작업이 두번째 일때 망설여져도 그냥 		하고 세번째 작업 시에 리팩토링을 실시한다.

사전 설계는 중요하기도 하지만, 적당한 사전 설계를 하고 구축해 나가면서 필요에 의해 리팩토링을 실행하는 것이 더욱 효율적이다.

---------------------------------------------------------------------------------------------------

2018/05/30 자바 성능 튜닝 이야기
From 219 to 342 Page
박진성


서버 튜닝
아파치 웹 서버 설정

WAS를 웹 서버로 사용하면 안된다. 웹에서 사용하는 애플리케이션서버이지 웹 서버가
아니다. 정적인 부분은 웹 서버에서 처리해야 한다. 웹 서버를 WAS 서버앞에 두지 않
으면 이미지, CSS, 자바스크립트, HTML 등을 처리하느라 아까운 WAS 서버의 스레드를 점
유하게 된다.

아파치 설치폴더 하단의 conf 디렉토리에 있는 httpd.conf 파일 수정
ThreadsPerChild는 웹서버가 사용하는 스레드의 개수를 지정한다.
MaxRequestsPerChild는 최대 요청 개수를 지정하는 부분이다. 기본값인 '0' 사용을 권장
Keep Alive 기능이 켜져있지 않으면, 매번 HTTP 연결을 맺었다 끊었다 하는 작업을 반
복한다. 기능이 켜져있으면 두개 정도의 연결을 열어서 끊지 않고, 연결을 계속 재사용
한다. 연결을 하기 위한 대기시간이 짧아지기 때문에 사용자가 느끼는 응답속도도 엄청
나게 빨라진다.
Keep Alive-Timeout 설정 -> Keep Alive on 시 같이 설정
초 단위로 Keep Alive가 끊기는 시간을 설정하기 위한 부분이다. 마지막 연결이 끝난
이후에 다음 연결이 될 때까지 얼마나 기다릴지를 지정한다.

---------------------------------------------------------------------------------

DB Connection Pool

운영중에는 최소 및 최대 값을 동일하게 하는것이 좋다. 사용자수가 갑자기 증가하면
ConnectionPool의 개수도 증가되어야하고, 증가할 때 대기시간이 발생할 확률이
크기 때문이다.

Session Timeout 시간 설정

web.xml 파일에 세션종료시간을 설정해주는게 성능에 좋다.
이 설정을 하지 않은 상태에서, WAS에서 따로 설정한 바가 없거나 세션객체의 invalidate()
메서드가 수행되지 않으면 세션은 삭제되지 않으므로 유의하자.

---------------------------------------------------------------------------------

GG의 원리 (Garbage Collection)

GC작업을 하는 가비지 컬렉터는 다음의 역할을 한다.
- 메모리 할당
- 사용중인 메모리 인식
- 사용하지 않는 메모리 인식

GC가 인식하고 할당하는 영역은 자바의 힙 영역이다.

==============================================================
2018/05/29 Refactoring:프로그램의 가치를 높이는 코드 정리 기술
From 77 to  116Page 
성현

ｏ 리팩토링의 용도

  ① 소프트웨어 설계 개선

    - 코드 설계가 깔끔하지 않으면 기능이 같은 코드가 중복되어 있어서 코드 길이가 길어진다. 설계를
개선하는 주요 방법 중 하나가 중복 코드를 없애는 것이다. 중복 코드 제거의 중요성은 나중에 코드를
수정할 때 절감하게 마련이다. 프로그램 크기로 인한 영향은 미미해서 시스템이 빨라지진 않지만 코드
수정은 훨씬 쉬워진다. 중복 코드 제거는 깔끔한 설계의 필수 요건이다.

  ② 소프트웨어의 이해

    - 프로그래밍에서 가장 중요한 것은 의도한 바를 정확히 전달하는 것이다. 그렇다고 해서 지나치게 타인
위주로 고려해가며 프로그래밍 할 필요없다 공동 프로젝트에서 다른 팀원이 본인의 코드를 신속히 파악해서
수정해야 하는 일도 있을 수 있다. 개발자는 다른 사람이 코드를 수정할 경우까지 고려하지 못하는 실수를
하기 쉬우며, 코드 이해 대상을 두루 고려하는 일도 중요하다.

  ③ 버그 찾기

    - 코드를 파악하기 쉬우면 버그 발견도 쉬워진다. 프로그램 구조를 명료하게 만들어서 내가 특정한 전제들이
확실해지면 버그를 놓치는 것이 불가능 할 정도가 된다.

  ④ 프로그래밍 속도

    - 리팩토링을 하면 코드 품질이 좋아진다. 깔끔한 설계는 전적으로 신속한 개발을 목적으로 한다. 설계가
깔끔하지 않으면 개발 초기의 잠시 동안엔 진행이 빠를지 몰라도 얼마 못 가서 개발 속도가 떨어진다. 특히
버그 찾기에 많은 시간을 낭비해서 문제다.

ｏ 리팩토링이 필요할 때

  ① 같은 작업을 3번째 반복하게 됬을 때

  ② 기능을 추가할 때

  ③ 버그를 수정할 때

  ④ 코드를 검수할 때

03.

중복 코드

  - 똑같은 코드 구조가 두 군데 이상 있을 때는 그 부분을 하나로 통일하면 프로그램이 개선된다.

장황한 메서드

  - 최적의 상태로 장수하는 객체 프로그램들은 공통적으로 메서드 길이가 짧다. 메서드의 기능을 한눈에 알
수 있는 메서드명을 사용하면 그 메서드 안의 코드를 분석하지 않아도 된다. 이를 위해서는 메서드를 훨씬
과감하게 쪼개야 한다.
